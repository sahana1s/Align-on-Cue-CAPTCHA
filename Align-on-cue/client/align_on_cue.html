<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Align on Cue</title>
<style>
body { font-family: system-ui, sans-serif; text-align:center; padding:30px; background:#f9fafb; }
#status { margin-top:14px; font-size:15px; color:#111827; min-height:20px; }
button { margin-top:14px; padding:10px 20px; border:none; border-radius:8px; background:#2563eb; color:white; font-size:15px; cursor:pointer; }
canvas { display:block; margin:20px auto; background:#f3f4f6; border-radius:50%; touch-action:none; }
</style>
</head>
<body>
<h2>Align on Cue</h2>
<p>Wait for the üîî beep, align the green bar with the red one, then click Submit (or press Space).</p>
<canvas id="stage" width="300" height="300" aria-label="alignment stage"></canvas>
<div id="status">Waiting for beep‚Ä¶</div>
<button id="submitBtn">Submit</button>

<script>
(() => {
const canvas = document.getElementById('stage');
const ctx = canvas.getContext('2d');
const status = document.getElementById('status');
const submitBtn = document.getElementById('submitBtn');
const W = canvas.width, H = canvas.height, R = 150;

// --- challenge params ---
const target = Math.floor(Math.random() * 360); // 0..360
const tolerance = 8;

let pointerAngle = 0;
let dragging = false, startX = 0, startAngle = 0, pointerId = null;
let beepActive = false, beepStart = 0, success = false;

// --- audio ---
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function resumeAudioContextOnce() {
  if (!audioCtx) { audioCtx = new AudioCtx(); audioCtx.resume().catch(()=>{}); }
}
function playBeep() {
  if(!audioCtx){ resumeAudioContextOnce(); }
  if(!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = 'sine';
  osc.frequency.value = 880;
  gain.gain.value = 0.15;
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  const now = audioCtx.currentTime;
  osc.start(now);
  osc.stop(now + 0.2);
}

// --- robust wrap-around difference (direction-agnostic) ---
function normalizeAngle(angle) {
    // Normalize angle to [-180, 180)
    angle = angle % 360;
    if (angle > 180) angle -= 360;
    if (angle <= -180) angle += 360;
    return angle;
}

function angleDiffAbs(a, b) {
    // Get absolute difference between angles
    let diff = Math.abs(normalizeAngle(a) - normalizeAngle(b));
    // If difference is greater than 90, then bars are parallel
    if (diff > 90) {
        diff = Math.abs(180 - diff);
    }
    return diff;
}

// --- drawing ---
let flashAlpha = 0;
function draw() {
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = '#f3f4f6';
  ctx.beginPath();
  ctx.arc(W/2,H/2,R,0,Math.PI*2);
  ctx.fill();

  if(flashAlpha>0){
    ctx.fillStyle = `rgba(255,255,255,${flashAlpha})`;
    ctx.beginPath();
    ctx.arc(W/2,H/2,R,0,Math.PI*2);
    ctx.fill();
  }

  ctx.save();
  ctx.translate(W/2,H/2);

  // target bar (no changes needed to rotation)
  ctx.save();
  ctx.rotate(target * Math.PI / 180);
  ctx.fillStyle = 'rgba(244,63,94,0.32)';
  ctx.fillRect(-90,-7,180,14);
  ctx.restore();

  // pointer bar (no changes needed to rotation)
  ctx.save();
  ctx.rotate(pointerAngle * Math.PI / 180);
  ctx.fillStyle = '#34d399';
  ctx.fillRect(-90,-7,180,14);
  ctx.restore();

  ctx.restore();
  requestAnimationFrame(draw);
}

// --- pointer handlers ---
canvas.addEventListener('pointerdown', e=>{
  resumeAudioContextOnce();
  dragging = true;
  pointerId = e.pointerId;
  startX = e.clientX;
  startAngle = pointerAngle;
});
canvas.addEventListener('pointermove', e=>{
  if(!dragging || e.pointerId !== pointerId) return;
  const dx = e.clientX - startX;
  pointerAngle = startAngle + dx/3;
});
canvas.addEventListener('pointerup', e=>{
  if(e.pointerId === pointerId) dragging = false;
});

// --- keyboard ---
document.addEventListener('keydown', e=>{
  if(e.key==='ArrowLeft'){ pointerAngle -= 2; }
  if(e.key==='ArrowRight'){ pointerAngle += 2; }
  if(e.key===' ') attemptSubmit();
});

// --- beep scheduling ---
function getRandomDuration() {
    // Returns random duration between 800ms and 1600ms
    return 800 + (Math.random() * 800);
}

function triggerBeep(){
    beepActive = true;
    beepStart = performance.now();
    flashAlpha = 0.6;
    playBeep();
    status.textContent = 'üîî Align now!';
    
    // Use closure to keep duration private
    const duration = getRandomDuration();
    setTimeout(()=>{
        beepActive = false;
        flashAlpha = 0;
        if(!success){
            status.textContent = '‚è≥ Beep ended. Waiting...';
            scheduleBeep();
        }
    }, duration);
}
function scheduleBeep(){
  const delay = 2000 + Math.random()*3000;
  setTimeout(triggerBeep, delay);
}

// --- submit ---
function attemptSubmit(){
    if(!beepActive){
        status.textContent = '‚è∞ Too early! Wait for the beep.';
        return;
    }
    const error = angleDiffAbs(pointerAngle, target);
    const reaction = performance.now() - beepStart;
    
    // Use a reasonable maximum duration for validation
    const maxAllowedReaction = 2000; // 2 seconds max
    
    if(error <= tolerance && reaction <= maxAllowedReaction){
        success = true;
        // status.textContent = `‚úÖ Verified! Error ${error.toFixed(1)}¬∞, reaction ${reaction.toFixed(0)}ms`;
        status.textContent = '‚úÖ Verified!';
        status.style.color = 'green';
        beepActive = false;
    } else if(error <= tolerance){
        // status.textContent = `‚ö†Ô∏è Too slow (${reaction.toFixed(0)}ms)`;
        status.textContent = '‚ö†Ô∏è Too slow';
        status.style.color = 'orange';
    } else {
        // status.textContent = `‚ùå Off by ${error.toFixed(1)}¬∞`;
        status.textContent = '‚ùå Try again';
        status.style.color = 'red';
    }
}

submitBtn.addEventListener('click', attemptSubmit);

// --- init ---
draw();
scheduleBeep();
})();
</script>
</body>
</html>
